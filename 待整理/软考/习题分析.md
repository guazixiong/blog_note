## 流水线计算

80%按照理论公式计算,若没有正确答案,按照实践公式计算指令执行时间.

k: 分几段,k就是几

n: 执行次数

如题:
![image-20250330112208401](%E7%BB%86%E8%8A%82%E7%82%B9.assets/image-20250330112208401.png)

流水线周期： 2ns

理论公式: 

> (2+2+1) + (100-1) * 2 = 203ns

实践公式:

取指、分析、执行三段，k为3.  

> (3 + 100 - 1) * 2 = 204ns

## 内存地址从A变B，共有多少k个地址单元

计算公式： B - A + 1

如题：

![image-20250330113912415](%E7%BB%86%E8%8A%82%E7%82%B9.assets/image-20250330113912415.png)

C7FFFH表示16进制(末位为H),转换为二进制为:1100 0111 1111 1111 1111

+1 : 1100 1000 0000 0000 0000

AC000H表示16进制(末位为H),转换为二进制为:1010 1100 0000 0000 0000

C7FFFH + 1 - AC000H = 1100 1000 0000 0000 0000 - 1010 1100 0000 0000 0000

​								= 1C000H

K: 表示2^10^

1C000 / 2^10^ = 0001 1100 0000 0000 0000 / 2^10^  

​					= (1*16^4^ + 12 * 16^3^ ) / 1024

​					= (65536 + 49152) / 1024

​					= 112

## 计算磁头记录处理时间

![image-20250330161658500](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250330161658500.png)

旋转周期为33ms,单独扇区耗时33ms/11=3ms,单缓冲区意味只能同时处理一个(多缓冲区可将记录依次加入,直接从缓冲区读取.)

以R0为例,读取R0记录,耗时3ms,处理3ms,此时磁头处于R2头,需要处理R1数据,需要等磁头转动一周回到R1,一共10扇区,共30ms. 

因此一个完整的扇区处理时间 = 读取扇区时间 + 处理扇区时间 + 跳转至下一个扇区的时间

​													= (读取扇区时间 + 跳转至下一个扇区的时间) + 处理扇区时间

​													= 一个磁盘旋转周期 + 处理扇区时间

​													= 33ms + 3ms = 36ms

一共有11个扇区: 从R~0~ ~ R~9~均需要一个完整扇区处理时间, R~10~只需要读取和处理时间,并不需要考虑磁头的时间.

因此最长: 一个完整的扇区处理时间 * (R~0~ ~ R~9~) + R~10~(读取+处理时间) = 36 *10 + 3+ 3 = 366ms

## 模冗余系统与混合系统可靠度

R~1~代表单可靠度.

系统可靠度 = R~1~ * R~2~ * R~3~ * …….. * R~n~

通过R~1~,R~2~…….R~m~的结果经由表决器,最后输出结果.  

![image-20250330175808418](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250330175808418.png)

类似题型,看串联还是并联, 串+并,求并集可靠性,按串行计算整体可靠性

## 循环校验码CRC

**海明校验码（Hamming Code）** 是一种 **纠错编码** 技术，主要用于 **检测和纠正数据传输或存储中的错误**。由理查德·海明（Richard Hamming）在1950年发明，常用于 **数据通信、存储设备**（如内存、硬盘）、**网络传输** 等领域。

### 模2除法

1. **运算规则：**

   - 加法和减法都采用 **异或（XOR）** 计算：

     - 0⊕0=0
     - 1⊕1=0
     - 0⊕1=1
     - 1⊕0=1

   - 没有进位与借位概念

     > 一致为0,不一致为1

2. **除法步骤：**

   - 被除数（Dividend） 和 除数（Divisor） 都是二进制数
   - 先将 **被除数** 和 **除数** 对齐
   - 从左往右依次比较，如果当前最高位是 1，就执行 **异或运算**（相当于“减法”），否则跳过
   - 重复上述步骤直到处理完所有位

3. **最终结果：**

   - 模2除法得到的 **商（Quotient）** 和 **余数（Remainder）**

![image-20250330181001175](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250330181001175.png)

### 循环校验码CRC

![image-20250330180616071](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250330180616071.png)

原始报文: `11001010101`

生成多项式为: ` x^4^ + x^3^ + x + 1 

> 按照多项式的每一项,去做二进制运算
>
> x^4^ : 1
>
> x^3^:1
>
> x: 1
>
> 1: 1
>
> 推到校验码为: 11011 

校验码为5位,在原始报文后追加(n-1)位0, 即4个0.  `110010101010000`

`1100101010000`对校验码`11011`进行模2除法,获得尾数`0011`. 发送报文追加`0011`,即`110010101010011`

### 海明校验码

![image-20250330181756491](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250330181756491.png)

信息1011, 根据公式2^r^>=x+r+1.  x为信息长度, 校验码r为3时,满足.

校验位位于: 1,2,4位; 2^0^ = 1, 2^1^ = 2, 2^2^ = 4

根据位数,确认信息1011,存放位置,后期求校验位

即: 101x1yz是最后的海明码.

拆解信息位所在位数, 7 = 2^2^ + 2^1^ + 2^0^, 6 = 2^2^ + 2^1^,5 = 2^2^ + 2^0^,3 = 2^1^ + 2^0^

x是第4位, 是2^2^,与2^2^有关系的是第7位,第6位,第5位 :  对原始码就异或操作: 1 ⊕ 0 ⊕ 1 = 0

y是第2位, 是2^1^,与2^1^有关系的是第7位,第6位,第3位  :  对原始码就异或操作: 1 ⊕ 0 ⊕ 1 = 0

z是第1位, 是2^0^,与2^0^有关系的是第7位,第5位,第3位  :  对原始码就异或操作: 1 ⊕ 1 ⊕ 1 = 1

## 页式存储和段式存储

### 一、定义

- **页式存储**：
  - 把内存划分成**固定大小的页（Page）**，比如4KB；
  - 程序的逻辑地址空间也被划分成同样大小的页；
  - 通过页表映射虚拟页到物理页，适用于**离散内存管理**。
- **段式存储**：
  - 把程序划分为**若干逻辑段（Segment）**，如代码段、数据段、堆栈段等；
  - 每段大小不一；
  - 通过段表映射，适合**逻辑结构化管理**。

### 二、对比表

| 比较项        | 页式存储               | 段式存储                       |
| ------------- | ---------------------- | ------------------------------ |
| 单位大小      | 固定大小页（如4KB）    | 可变大小段                     |
| 内存分配粒度  | 固定                   | 不固定                         |
| 地址结构      | 页号 + 页内偏移        | 段号 + 段内偏移                |
| 适合场景      | 离散分配、避免外部碎片 | 结构清晰、便于访问不同逻辑模块 |
| 典型映射方式  | 页表（Page Table）     | 段表（Segment Table）          |
| 内部/外部碎片 | 可能有**内部碎片**     | 容易产生**外部碎片**           |
| 地址空间支持  | 不支持逻辑分段         | 支持逻辑结构分段               |
| 程序可移植性  | 高                     | 稍差，依赖逻辑段定义           |

### 三、举例说明

#### 页式存储：

> 程序运行时被拆成多个页，操作系统在物理内存中找到任意空闲页，装进去，哪怕是不连续的。程序员完全不用关心内存在哪，只看逻辑地址。

#### 段式存储：

> 程序被明确划分为代码段、数据段、堆栈段等，程序访问时通过段号+偏移定位。例如访问代码段第50个字节。

------

### 四、页段结合（现代系统）

- 现代操作系统（如x86架构）**同时使用段式和页式**：
  - 先通过段表确定逻辑段；
  - 然后在段中使用页表进行分页管理；
  - 这样既支持**结构化管理**，又实现了**高效内存利用**。

效率降低, 追加相联存储器(由高速缓存器组成,内存存储),速度快

## 多级索引管理文件

![image-20250413162514165](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250413162514165.png)

要区分好逻辑块和物理块.

![image-20250413162934599](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250413162934599.png)

 问题一：（1）文件File1中**逻辑块号为5和261**的物理块号是多少？

🧠 Step 1：File1 的逻辑块号分布

- **直接地址（i-addr[0]~i-addr[4]）**可访问逻辑块号：**0~4**
- **i-addr[5]：一级间接地址**，可访问逻辑块号：**5~(5+255)=260**  (4 + 256) = 260
- **i-addr[6]：一级间接地址**，可继续访问：**261~(261+255)=516**  (260 + 256) = 516
- **i-addr[7]：二级间接地址**，理论最大支持：256×256=65536块

🧠 Step 2：访问逻辑块号5

- 属于一级间接地址（第一个），由 i-addr[5] = 90 指向索引块
- 从图中看到，索引块90 指向的首个地址为 **块号58**
- 所以：逻辑块号5 → 一级间接 → 第0项 → **块号58**

🧠 Step 3：访问逻辑块号261

- 超出 i-addr[5] 所能覆盖（0~260），属于 i-addr[6] 代表的一级间接地址块
- i-addr[6] = 91，对应的索引块，图中指向第一个块为 **187**
- 所以：逻辑块号261 → 第二个一级间接地址的第0项 → **块号187**

------

✅ **答案（1）选 C：58 和 187**

✅ 问题二：（2）101 号物理块存放的是？

- 查看图中 i-addr[7] = 101，对应**二级间接索引表**
- 图示中，101 对应的索引块中有：261、516 等块号
- 说明它是一个指向多个一级间接表的指针列表

✅ 所以：**101号物理块是“二级地址索引表”**

## 位示图计算

![image-20250413164241480](%E4%B9%A0%E9%A2%98%E5%88%86%E6%9E%90.assets/image-20250413164241480.png)

🧠 要求：

将第 **4195号** 物理块分配给文件，问这个块的使用情况在哪一个字中、哪一位。

第一步：确定在哪一个“字”中（每个字32位）

因为每个字有 32 位，一个字能表示 32 个物理块。 那么物理块号 4195 所在的字是：

```yaml
4195 ÷ 32 = 131 余 3
```

➡️ 所以答案是第 **132 个字***（余数自动+1）
 👉 正确选项是：**(1) D. 132**

第二步：确定是该字的哪一位？

余数是 **3**，说明是这个字中的第 **4 位（从0开始数）**

注意：图中描述位顺序是从高位（31）到低位（0），所以：

- 第 0 位是最右边
- 第 3 位是从右往左数第 4 位

所以要将该字的第 3 位 **从 0 改成 1**

👉 正确选项是：**(2) B. 该字的第3位置 “1”**

✅ 最终答案：

- (1) D. 132
- (2) B. 该字的第3位位置 “1”
