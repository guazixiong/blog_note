> 当前进度：2.15 随机存储器与只读存储器
>
> 计算公式,为什么要这么算?

# 软考知识点-辅助说明

## 数据的表示

### 原码,反码,补码,移码

反码: 相当于原码来说,正数不变,负数在数值位取反;

补码: 

+ 记忆方式一: 相当于反码来说,正数不变,负数+1 
+ 记忆方式二: 非0外,相对于原码,正数不变,负数数值位取反并+1

移码: 在补码的基础上,符号位取反

|      | 数值1     | 数值-1    | 1-1       | 整数表示范围                                                 | 8bit     |
| ---- | --------- | --------- | --------- | ------------------------------------------------------------ | -------- |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 | -(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1                       | -127~127 |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 | -(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1                       | -127~127 |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 | -2<sup>n-1</sup>~2<sup>n-1</sup>-1(在+0和-0可以用一个来表示) | -128~127 |
| 移码 | 1000 0001 | 0111 1111 | 1000 0000 |                                                              |          |



计算机中对原码的加减法运算比较复杂,需要进行符号位和数值位的分别处理.  引入反码进行计算.

反码的加减法运算可以简化为普通的二进制加法运算,但存在反码移除和表示正零、负零的问题。

```bash
+0   0000 0000
-0    1000 0000
```

补码的加减法运算可以简化为普通的二进制加法运算,且不会出现反码溢出的问题,同时也可以正确表示正零和负零的问题.

移码: 不常用于存储和运算,而更多用于显示和输出.  主要作用是将有符号数转换为无符号数,便于进行数值比较和排序.

### 浮点数的运算

浮点数标识: **N = M*R<sup>e</sup>**

就是科学计数法: 

+ 1000 = 1.0 * 10<sup>3</sup>
+ 119 = 1.19 * 10<sup>2</sup>

当加减浮点数时,如

1000 + 119 

= 1.0 * 10<sup>3</sup> + 1.19 * 10<sup>2</sup>

= 1.0 * 10<sup>3</sup> + 0.119 * 10<sup>3</sup>

= 1.119 * 10<sup>3</sup>

> 请注意, 当运算浮点数时,我们要首先保证高位,否则运算完成后,仍需要从低位换到高位
>
> 1000 + 119 
>
> = 1.0 * 10<sup>3</sup> + 1.19 * 10<sup>2</sup>
>
> = 10.0 * 10<sup>2</sup> + 1.19 * 10<sup>2</sup>
>
> = 11.19 * 10<sup>2</sup>
>
> = 1.119 * 10<sup>3</sup>
>
> 因此,在计算时, 要保证小数点前不为0,并向高位进行转换.

## Flyn计算机体系结构分类方法

| 体系结构类型         | 结构                                                    | 关键特性                               | 代表                                           |
| -------------------- | ------------------------------------------------------- | -------------------------------------- | ---------------------------------------------- |
| 单指令流单数据流SISD | 控制部分： 一个<br />处理器： 一个<br />主存模块： 一个 |                                        | 单片机                                         |
| 单指令流多数据流SIMD | 控制部分： 一个<br />处理器： 多个<br />主存模块： 多个 | 各处理器以异步的形式执行同一条指令     | 阵列处理机<br />并行处理机<br />超级向量处理机 |
| 多指令流单数据流MISD | 控制部分： 多个<br />处理器： 一个<br />主存模块： 多个 | 被证明不可能.至少不实际                | 目前没有,有文献称流水线计算机为此类            |
| 多指令流多数据流MIMD | 控制部分： 多个<br />处理器： 多个<br />主存模块： 多个 | 能够实现作业、任务、指令等各级全面并行 | 多处理机系统<br />多计算机                     |

## CISC与RISC

![image-20240801222504186](%E8%BD%AF%E8%80%83.assets/image-20240801222504186.png)

CISC 在计算机不发达的情况下，定制化的指令类型，包含很多种指令集。

RISC 是剔除了CISC中不常用的指令集，便于走向平常人家，并使用寄存器提高读写

## 流水线

### 流水线计算公式

#### 基础概念

工业流水线,分组执行;

指令流水线,可以分为

+ 取指: 取出指令
+ 分析: 分析指令
+ 执行: 执行指令

![image-20240807212941144](%E8%BD%AF%E8%80%83.assets/image-20240807212941144.png)

#### 计算公式

流水线计算公式:  `1条指令执行时间 + (指令条数 - 1) * 流水线周期`





> $$
> 理论公式: (t1+t2+..+tk) + (n-1)*△t
> $$

+ t1…tk为指令流水线时长;
+ n为指令数
+ △t为流水线周期:  Max(取指,分析,执行);

将整个过程分为两个部分:

1. 第一个指令周期; (取指,分析,执行都执行完为第一个周期)
2. 其余n-1个周期

> $$
> 实践公式: (k+n-1)*△t
> $$
>
> 

+ k为流水线段数; 如: 假如流水线有取指,分析,执行三部分,那就是3
+ n为指令数
+ △t为流水线周期Max(取指,分析,执行)

实际过程中,取指,分析,执行的时间可能不一致,可能需要将其看待为同一个流水线周期;

如: 取指2ns,分析2ns,执行1ns,  第一个指令周期,应该为(2+2+1), 但在实际中可以看待为(2+2+2)

> ​	考试时,首选理论公式,然后才是实践公式

### 流水线吞吐率

单位时间内流水线所完成的任务数量或输出的结果数量
$$
TP = 指令条数 / 流水线执行时间
$$
流水线最大吞吐率:
$$
TP_(max) = 1/△t
$$

+ △t为流水线周期Max(取指,分析,执行)

理想吞吐率,不出现其他问题.

### 流水线加速比

$$
S = 不使用流水线执行时间 / 使用流水线执行时间.
$$

### 流水线的效率

$$
E = n个任务占用的时空区/k个流水段的总的时空
$$

假若流水线设计有4个阶段,分别耗时△t,△t,△t,3△t;  连续处理4个指令消耗了15△t时间,

+ n个任务占用的时空区 = 流水线阶段耗时之和 * 指令数 = (△t+△t+△t+3△t) * 4
+ k个流水段的总的时空区 = 连续处理指令消耗的时间 * 流水阶段数 = 15△t * 4

$$
E = (流水线阶段耗时之和*指令数) / (连续处理指令消耗的时间 * 流水阶段数)
$$

## 层次化存储结构

CPU(寄存器) -> CACHE(缓存,相同请求,提高吞吐) -> 内存(主存) -> 外存(辅存)

cache非必要,但为了提高效率,命中缓存和命中内存,执行效率成倍数增长. 跟写程序一样,引入缓存,提高并发.

cache为了提高cpu的输入输出的速率,突破冯诺依曼瓶颈,即cpu与存储系统间数据传送贷款限制.

> 冯诺依曼结构, cpu与内存直接交互; 
>
> 哈佛结构: 区分指令和数据, 减少交互.
>
> 冯诺依曼架构不区分数据与指令，将两者放在同一内存中；而哈佛结构将两者分别存放在Instruction Memory和Data Memory。 指令和数据放在一起的后果是取指令和取数据不能同时进行，否则会引起访存的混乱
>
> 究竟什么是冯诺依曼瓶颈(von Neumann Bottleneck)？ - 掘金: https://juejin.cn/post/7028590509882884110

以下寄存器,速度最快的是那个? 

寄存器 > cache > 内存 > 外存



Cache + 主存的平均周期
$$
t_3 = h*t_1+(1-h)*t_2
$$

+ t3: Cache + 主存的平均周期
+ h: cache的命中率
+ t1: cache的周期时间
+ t2: 主存的周期时间

t3 = 命中cache的周期时间 + 命中主存的周期时间 = cache命中率 * cache周期 + 主存命中率 * 主存周期

## 主存-分类

随机存取存储器: 断电后,存储器内容丢失

只读存储器: 断电后,存储器内容不丢失, 如bios



懵逼~~~

![image-20240807225003352](%E8%BD%AF%E8%80%83.assets/image-20240807225003352.png)

16进制/1024 = 转换为10进制 / 1024 = 112

