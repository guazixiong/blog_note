[toc]

# 数据加密后如何进行模糊匹配

在数据加密后，你的明文信息（比如用户姓名、手机号等）被加密存储，数据库就失去了原有的**模糊匹配能力**（如`LIKE '%张三%'`），因为加密后的数据是完全不同的密文，无法参与模糊搜索。

下面是常见的几种**解决思路**，你可以根据业务场景选用：

------

## ✅ 方案一：**使用同态加密或可搜索加密（SSE）**

> **安全性最高，性能成本大**

+ 同态加密 / 可搜索加密允许你对密文进行某些操作，比如比较或搜索。
+ 比如，**CryptDB**、**Mylar** 这类中间件层支持密文模糊查询。
+ 国密领域也有类似“可验证加密”研究方向。

**优点**：安全性高，不泄露明文。
 **缺点**：性能开销大，部署复杂，商业项目中较少落地。

------

## ✅ 方案二：**引入“搜索专用字段”**

> **推荐在敏感信息不多的业务中使用，平衡安全与功能**

### 实现方式：

1. 在数据库中**新增一个冗余字段**，比如 `name_search_key`。
2. 存储时将姓名“张三”**转换为搜索关键词**，如：
   + 拼音简拼（zs）
   + 全拼（zhangsan）
   + 使用分词结果（“张”“三”）
3. 对该字段做模糊查询，如 `LIKE '%zhang%'`。

### 示例表结构：

```
sql复制编辑字段名         | 说明
--------------|---------------------
name_encrypt   | 加密后的姓名
name_search_key | 经过处理的搜索关键词（明文或伪明文）
```

### 查询方式：

```
sql复制编辑SELECT * FROM user_info
WHERE name_search_key LIKE '%zhang%';
```

**优点**：

+ 保留了模糊匹配能力
+ 原始敏感字段仍加密，具备一定保护能力

**缺点**：

+ search_key 字段可能泄露部分隐私（需做访问控制）

------

## ✅ 方案三：**前端/服务端搜索 + 明文缓存（只适合小数据量）**

> **适用于数据量小、性能可控的系统**

1. 后端解密所有候选数据（或从缓存中读取明文）

2. 在服务层做模糊匹配

   ```
   java复制编辑List<User> users = decryptedUserList.stream()
     .filter(u -> u.getName().contains("张"))
     .collect(Collectors.toList());
   ```

**优点**：逻辑简单，容易实现
 **缺点**：不适合大数据量，性能差；数据泄露风险高（缓存/内存中是明文）

------

## ✅ 方案四：**加密前做部分哈希或模糊分组**

> **模糊搜索变“模糊索引”**

1. 设计分组标签，如把手机号“18312345678”归入“183****5678”
2. 存储一个模糊的标识字段
3. 查询时匹配这个“脱敏化标识”

**适用于：**

+ 手机号、银行卡这类格式化信息

------

## ✅ 风险提醒：

+ 模糊查询字段 **可能成为攻击入口**，特别是用户自行输入模糊词时（防止注入攻击）。
+ 冗余字段或索引字段若未加密，**必须加访问控制和脱敏限制**。
+ 系统需要明确区分“可查字段”与“加密字段”，防止误用。

------

## ✅ 建议总结：

| 方案         | 适用场景                         | 推荐度           |
| ------------ | -------------------------------- | ---------------- |
| 可搜索加密   | 安全级别极高、对功能要求高的系统 | ⭐⭐（技术门槛高） |
| 冗余模糊字段 | 实用性强，适合大多数业务系统     | ⭐⭐⭐⭐             |
| 后端明文搜索 | 测试环境、数据量小场景           | ⭐⭐               |
| 模糊标识字段 | 格式类字段（手机号、卡号）       | ⭐⭐⭐              |

