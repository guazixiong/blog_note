# 如何设计电商秒杀系统

​		电商行业在近十几年中，经历过大大小小的促销活动和秒杀上百次，每次做秒杀瞬时访问量会翻数十倍，甚至数百倍。对系统架构是巨大的考验，期间也曾经历过系统宕机，甚至整体雪崩。那么我们怎么**设计秒杀系统，才能保证秒杀系统的高性能和稳定性，同时还要保证日常业务不受影响呢？**

​		先看看秒杀场景特点。秒杀开始前几分钟，大量用户开始进入秒杀商品详情页面，很多人开始频繁刷新秒杀商品详情页，这时秒杀商品详情页访问量会猛增。秒杀开始，大量用户开始抢购，这时创建订单，扣库存压力会显著增大。实际上，秒杀场景基本都是秒杀参与人多，秒杀成功的人却寥寥无几，经常是几十万人或者更多人抢几百个商品库存。

我们可以将电商系统的架构简化成下图所示。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408180937121.jpg)

由图所示，我们可以简单的将电商系统的核心层分为：负载均衡层、应用层和持久层。接下来，我们就预估下每一层的并发量。

- 假如负载均衡层使用的是高性能的Nginx，则我们可以预估Nginx最大的并发度为：10W+，这里是以万为单位。
- 假设应用层我们使用的是Tomcat，而Tomcat的最大并发度可以预估为800左右，这里是以百为单位。
- 假设持久层的缓存使用的是Redis，数据库使用的是MySQL，MySQL的最大并发度可以预估为1000左右，以千为单位。Redis的最大并发度可以预估为5W左右，以万为单位。

所以，负载均衡层、应用层和持久层各自的并发度是不同的，那么，为了提升系统的总体并发度和缓存，我们通常可以采取哪些方案呢？

**（1）系统扩容**

系统扩容包括垂直扩容和水平扩容，增加设备和机器配置，绝大多数的场景有效。

**（2）缓存**

本地缓存或者集中式缓存，减少网络IO，基于内存读取数据。大部分场景有效。

**（3）读写分离**

采用读写分离，分而治之，增加机器的并行处理能力。

其实，整个秒杀的业务场景并不复杂，可即查看参与秒杀的商品信息，加上购买和支付的动作，如下图所示。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/7163baa9283a3754382feda9e16d890c.png)

## 秒杀系统的特点

这里，我们可以使用12306网站来举例，每年春运时，12306网站的访问量是非常大的，但是网站平时的访问量却是比较平缓的，也就是说，每年春运时节，12306网站的访问量会出现瞬时突增的现象。

再比如，小米秒杀系统，在上午10点开售商品，10点前的访问量比较平缓，10点时同样会出现并发量瞬时突增的现象。

所以，秒杀系统的流量和并发量我们可以使用下图来表示。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408180958185.jpg)

由图可以看出，秒杀系统的并发量存在瞬时凸峰的特点，也叫做**流量突刺**现象。

我们可以将秒杀系统的特点总结如下。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181009275.jpg)

**（1）限时、限量、限价**

在规定的时间内进行；秒杀活动中商品的数量有限；商品的价格会远远低于原来的价格，也就是说，在秒杀活动中，商品会以远远低于原来的价格出售。

例如，秒杀活动的时间仅限于某天上午10点到10点半，商品数量只有10万件，售完为止，而且商品的价格非常低，例如：1元购等业务场景。

**限时、限量和限价可以单独存在，也可以组合存在。**

**（2）活动预热**

需要提前配置活动；活动还未开始时，用户可以查看活动的相关信息；秒杀活动开始前，对活动进行大力宣传。

**（3）持续时间短**

购买的人数数量庞大；商品会迅速售完。

在系统流量呈现上，就会出现一个突刺现象，此时的并发访问量是非常高的，大部分秒杀场景下，商品会在极短的时间内售完。

### 秒杀系统的技术特点

我们可以将秒杀系统的技术特点总结如下。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181037529.jpg)

**（1）瞬时并发量非常高**

大量用户会在同一时间抢购商品；瞬间并发峰值非常高。

**（2）读多写少**

系统中商品页的访问量巨大；商品的可购买数量非常少；库存的查询访问数量远远大于商品的购买数量。

在商品页中往往会加入一些限流措施，例如早期的秒杀系统商品页会加入验证码来平滑前端对系统的访问流量，近期的秒杀系统商品详情页会在用户打开页面时，提示用户登录系统。这都是对系统的访问进行限流的一些措施。

**（3）流程简单**

秒杀系统的业务流程一般比较简单；总体上来说，秒杀系统的业务流程可以概括为：下单减库存。

## 秒杀架构原则

+ 尽量将请求拦截在系统上游

传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】。

+ 读多写少的常用多使用缓存

这是一个典型的 **读多写少**的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，**非常适合使用缓存** 。

## 秒杀三阶段

通常，从秒杀开始到结束，往往会经历三个阶段：

- **准备阶段**：这个阶段也叫作系统预热阶段，此时会提前预热秒杀系统的业务数据，往往这个时候，用户会不断刷新秒杀页面，来查看秒杀活动是否已经开始。在一定程度上，通过用户不断刷新页面的操作，可以将一些数据存储到Redis中进行预热。
- **秒杀阶段**：这个阶段主要是秒杀活动的过程，会产生瞬时的高并发流量，对系统资源会造成巨大的冲击，所以，在秒杀阶段一定要做好系统防护。
- **结算阶段：** 完成秒杀后的数据处理工作，比如数据的一致性问题处理，异常情况处理，商品的回仓处理等。

针对这种短时间内大流量的系统来说，就不太适合使用系统扩容了，因为即使系统扩容了，也就是在很短的时间内会使用到扩容后的系统，大部分时间内，系统无需扩容即可正常访问。 那么，我们可以采取哪些方案来提升系统的秒杀性能呢？

## 秒杀系统方案

针对秒杀系统的特点，我们可以采取如下的措施来提升系统的性能。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181100267.jpg)

**（1）异步解耦**

将整体流程进行拆解，核心流程通过队列方式进行控制。

**（2）限流防刷**

控制网站整体流量，提高请求的门槛，避免系统资源耗尽。

**（3）资源控制**

将整体流程中的资源调度进行控制，扬长避短。

> 数据预热,限制高并发流量,减少同一时刻请求资源.业务异步解耦,及时反馈.

### 数据限流

“秒杀开始前几分钟，大量用户开始进入秒杀商品详情页面，很多人开始频繁刷新秒杀商品详情页，这时秒杀商品详情页访问量会猛增”。如果请求全部打到后端服务，那后端服务的压力会非常大（后端服务要处理业务逻辑，而且还要访问数据库，吞吐量比较低）。

考虑到秒杀是运营同学提前安排的活动，要秒杀哪些商品、商品价格等信息在秒杀活动开始前已经确定下来，所以我们可以把秒杀商品详情页做成静态页面，把商品详情、商品价格等参数、评论评价等信息全部放在这个静态页面里，然后把这个静态页面上传到CDN上预热（**CDN是内容分发网络，可以简单理解成互联网上的巨大的缓存，用于存放静态页面、图片、视频等，可以显著提高访问速度**），用CDN扛流量，这样大量的商品详情页的访问请求就不用访问自己的网站（源站）。这样既可以提高访问速度，也没有给网站增加压力，同时也减少了网站带宽压力。

![1](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/6782422318f27e70a93d5c8c201d5fcfd06e2a37.jpeg)

如果在秒杀活动开始时，并发量太高时，我们可以将用户的请求放入队列中进行处理，并为用户弹出排队页面。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181120264.jpg)

对于瞬时流量洪峰可以采用倒三角的分层级逐层控制方式，共分为CDN、反向代理（Nginx）、后端服务及DB这四个层级。接下来，就来看看每一层级是怎么控制流量的，如下图所示。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/64897d050d0296c11bb19c9ee6fe45ce.png)

## 秒杀系统时序图

网上很多的秒杀系统和对秒杀系统的解决方案，并不是真正的秒杀系统，他们采用的只是同步处理请求的方案，一旦并发量真的上来了，他们所谓的秒杀系统的性能会急剧下降。我们先来看一下秒杀系统在同步下单时的时序图。

### 同步下单流程(低并发)

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181136593.jpg)

#### 同步下单-秒杀请求

在同步下单流程中，首先，用户发起秒杀请求。商城服务需要依次执行如下流程来处理秒杀请求的业务。

**（1）识别验证码是否正确**

商城服务判断用户发起秒杀请求时提交的验证码是否正确。

**（2）判断活动是否已经结束**

验证当前秒杀活动是否已经结束。

**（3）验证访问请求是否处于黑名单**

在电商领域中，存在着很多的恶意竞争，也就是说，其他商家可能会通过不正当手段来恶意请求秒杀系统，占用系统大量的带宽和其他系统资源。此时，就需要使用风控系统等实现黑名单机制。为了简单，也可以使用拦截器统计访问频次实现黑名单机制。

**（4）验证真实库存是否足够**

系统需要验证商品的真实库存是否足够，是否能够支持本次秒杀活动的商品库存量。

**（5）扣减缓存中的库存**

在秒杀业务中，往往会将商品库存等信息存放在缓存中，此时，还需要验证秒杀活动使用的商品库存是否足够，并且需要扣减秒杀活动的商品库存数量。

**（6）计算秒杀的价格**

由于在秒杀活动中，商品的秒杀价格和商品的真实价格存在差异，所以，需要计算商品的秒杀价格。

**注意：如果在秒杀场景中，系统涉及的业务更加复杂的话，会涉及更多的业务操作，这里，我只是列举出一些常见的业务操作。**

#### 同步下单-提交订单

**（1）订单入口**

将用户提交的订单信息保存到数据库中。

**（2）扣减真实库存**

订单入库后，需要在商品的真实库存中将本次成功下单的商品数量扣除。

如果我们使用上述流程开发了一个秒杀系统，当用户发起秒杀请求时，由于系统每个业务流程都是串行执行的，整体上系统的性能不会太高，当并发量太高时，我们会为用户弹出下面的排队页面，来提示用户进行等待。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408181120264.jpg)

此时的排队时间可能是15秒，也可能是30秒，甚至是更长时间。这就存在一个问题：**在用户发起秒杀请求到服务器返回结果的这段时间内，客户端和服务器之间的连接不会被释放，这就会占大量占用服务器的资源**。

> **网上很多介绍如何实现秒杀系统的文章都是采用的这种方式，那么，这种方式能做秒杀系统吗？答案是可以做，但是这种方式支撑的并发量并不是太高。此时，有些网友可能会问：我们公司就是这样做的秒杀系统啊！上线后一直在用，没啥问题啊！我想说的是：使用同步下单方式确实可以做秒杀系统，但是同步下单的性能不会太高。之所以你们公司采用同步下单的方式做秒杀系统没出现大的问题，那是因为你们的秒杀系统的并发量没达到一定的量级，也就是说，你们的秒杀系统的并发量其实并不高。**

### 异步下单流程(高并发)

既然同步下单流程的秒杀系统称不上真正的秒杀系统，那我们就需要采用异步的下单流程了。异步的下单流程不会限制系统的高并发流量。

![img](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/20200408182019813.jpg)

#### 异步下单-秒杀请求

用户发起秒杀请求后，商城服务会经过如下业务流程。

**（1）检测验证码是否正确**

用户发起秒杀请求时，会将验证码一同发送过来，系统会检验验证码是否有效，并且是否正确。

**（2）是否限流**

系统会对用户的请求进行是否限流的判断，这里，我们可以通过判断消息队列的长度来进行判断。因为我们将用户的请求放在了消息队列中，消息队列中堆积的是用户的请求，我们可以根据当前消息队列中存在的待处理的请求数量来判断是否需要对用户的请求进行限流处理。

例如，在秒杀活动中，我们出售1000件商品，此时在消息队列中存在1000个请求，如果后续仍然有用户发起秒杀请求，则后续的请求我们可以不再处理，直接向用户返回商品已售完的提示。

所以，使用限流后，我们可以更快的处理用户的请求和释放连接的资源。

![2](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/e3f0e852e7038134d490273fc7741bc1d019d760.jpeg)

**（3）发送MQ**

用户的秒杀请求通过前面的验证后，我们就可以将用户的请求参数等信息发送到MQ中进行异步处理，同时，向用户响应结果信息。在商城服务中，会有专门的异步任务处理模块来消费消息队列中的请求，并处理后续的异步流程。

在用户发起秒杀请求时，异步下单流程比同步下单流程处理的业务操作更少，它将后续的操作通过MQ发送给异步处理模块进行处理，并迅速向用户返回响应结果，释放请求连接。

#### 异步下单-异步处理

我们可以将下单流程的如下操作进行异步处理。

（1）判断活动是否已经结束

（2）判断本次请求是否处于系统黑名单，为了防止电商领域同行的恶意竞争可以为系统增加黑名单机制，将恶意的请求放入系统的黑名单中。可以使用拦截器统计访问频次来实现。

（3）扣减缓存中的秒杀商品的库存数量。

**库存可以放到Reids缓存中，来提高扣减库存吞吐能力。对于热点商品的库存可以利用Redis分片存储。**

（4）生成秒杀Token，这个Token是绑定当前用户和当前秒杀活动的，只有生成了秒杀Token的请求才有资格进行秒杀活动。

这里我们引入了异步处理机制，**在异步处理中，系统使用多少资源，分配多少线程来处理相应的任务，是可以进行控制的。**

#### 异步下单-短轮询查询秒杀结果

这里，可以采取客户端短轮询查询是否获得秒杀资格的方案。例如，客户端可以每隔3秒钟轮询请求服务器，查询是否获得秒杀资格，这里，我们在服务器的处理就是判断当前用户是否存在秒杀Token，如果服务器为当前用户生成了秒杀Token，则当前用户存在秒杀资格。否则继续轮询查询，直到超时或者服务器返回商品已售完或者无秒杀资格等信息为止。

采用短轮询查询秒杀结果时，在页面上我们同样可以提示用户排队处理中，但是此时客户端会每隔几秒轮询服务器查询秒杀资格的状态，相比于同步下单流程来说，无需长时间占用请求连接。

此时，**可能会有网友会问：采用短轮询查询的方式，会不会存在直到超时也查询不到是否具有秒杀资格的状态呢？答案是：有可能！** 这里我们试想一下秒杀的真实场景，商家参加秒杀活动本质上不是为了赚钱，而是提升商品的销量和商家的知名度，吸引更多的用户来买自己的商品。所以，我们不必保证用户能够100%的查询到是否具有秒杀资格的状态。

#### 异步下单-秒杀结算

**（1）验证下单Token**

客户端提交秒杀结算时，会将秒杀Token一同提交到服务器，商城服务会验证当前的秒杀Token是否有效。

**（2）加入秒杀购物车**

商城服务在验证秒杀Token合法并有效后，会将用户秒杀的商品添加到秒杀购物车。

#### 异步下单-提交订单

**（1）订单入库**

将用户提交的订单信息保存到数据库中。

**（2）删除Token**

秒杀商品订单入库成功后，删除秒杀Token，设置幂等性。

![3](%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%95%86%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets/d92d481ecc0d891c51cbb411f263c8ff11eabeef.jpeg)

**这里大家可以思考一个问题：我们为什么只在异步下单流程的粉色部分采用异步处理，而没有在其他部分采取异步削峰和填谷的措施呢？**

这是因为在异步下单流程的设计中，无论是在产品设计上还是在接口设计上，我们在用户发起秒杀请求阶段对用户的请求进行了限流操作，可以说，系统的限流操作是非常前置的。在用户发起秒杀请求时进行了限流，系统的高峰流量已经被平滑解决了，再往后走，其实系统的并发量和系统流量并不是非常高了。

**所以，网上很多的文章和帖子中在介绍秒杀系统时，说是在下单时使用异步削峰来进行一些限流操作，那都是在扯淡！ 因为下单操作在整个秒杀系统的流程中属于比较靠后的操作了，限流操作一定要前置处理，在秒杀业务后面的流程中做限流操作是没啥卵用的。**



网络：

秒杀前要和网络运营商、CDN服务商提前申请带宽。

还有哪些细节要考虑：

1.如何避免超卖？如果在redis中扣减库存，可以利用decr命令扣减库存，decr是原子操作，在分布式环境下也不会有并发问题，decr扣减库存后，判断返回值，如果返回值小于0，扣减库存失败，秒杀也就失败了；如果在数据库中扣减库存可以在where后面加上库存大于0的条件，来避免库存被减成负值。这样就可以避免超卖情况发生了。

2.接口防刷，前面已经提到过，在网关层对下单等接口按userID限流。

3.网关层除了对userID做限流外，还要做整体限流。在实际访问量超过预估访问量时，整体限流可以起到保护作用，避免系统被压垮。

4.防止重复下单，按userID限流已经起到了防止重复下单的作用。假如限制同一个用户10分钟能下一次单，一般情况下10分钟内，商品早已经被抢光了，用户也就没有再次下单的机会了。

5.可以结合风控系统，在网关层把羊毛党等有问题的用户请求直接拒掉。

6.可以在网关层上面再加一层防火墙或者高防服务，来防御DDos等分布式网络攻击。

## 秒杀问题

### 前端倒计时

出于性能原因这个 **一般由js调用客户端本地时间** ，就有可能出现客户端时钟与服务器时钟不一致，另外服务器之间也是有可能出现时钟不一致。

**客户端与服务器时钟不一致可以采用客户端定时和服务器同步时间**

**一般来说网络不会成为瓶颈，即使成为瓶颈也可以考虑多机房专线连通，加智能DNS的解决方案** ；web服务器之间时间不同步可以采用统一时间服务器的方式，
**比如每隔1分钟所有参与秒杀活动的web服务器就与时间服务器做一次时间同步** 。

### 接入风控系统

在用户下单前,接入风控系统,接入黑名单、限制用户uid单位时间内请求次数来进一步的进行限流。

### 如何控制秒杀商品页面购买按钮的点亮

购买按钮只有在秒杀开始的时候才能点亮，在此之前是灰色的。如果该页面是动态生成的，当然可以在服务器端构造响应页面输出，控制该按钮是灰色还是点亮，但是为了减轻服务器端负载压力，更好地利用CDN、反向代理等性能优化手段，该页面被设计为静态页面，缓存在CDN、反向代理服务器上，甚至用户浏览器上。秒杀开始时，用户刷新页面，请求根本不会到达应用服务器。

**解决方案** ：使用JavaScript脚本控制，
**在秒杀商品静态页面中加入一个JavaScript文件引用，该JavaScript文件中包含秒杀开始标志为否**
；当秒杀开始的时候生成一个新的JavaScript文件（ **文件名保持不变，只是内容不一样** ），更新秒杀开始标志为是，**加入下单页面的URL及随机数参数（这个随机数只会产生一个，即所有人看到的URL都是同一个，服务器端可以用redis这种分布式缓存服务器来保存随机数）**，并被用户浏览器加载，控制秒杀商品页面的展示。**这个JavaScript文件的加载可以加上随机版本号（例如xx.js?v=32353823），这样就不会被浏览器、CDN和反向代理服务器缓存** 。这个JavaScript文件非常小，即使每次浏览器刷新都访问JavaScript文件服务器也不会对服务器集群和网络带宽造成太大压力。

### 如何只允许第一个提交的订单被发送到订单子系统

由于最终能够成功提交订单的用户只有一个，为了减轻下单页面服务器的负载压力，可以**控制进入下单页面的入口，只有少数用户能进入下单页面，其他用户直接进入秒杀结束页面** 。

#### 1. 使用原子操作

确保提交订单的操作是原子性的，这意味着每次只有一个操作可以修改数据。在多个用户同时尝试购买时，原子操作可以确保只有第一个有效的订单被处理。这可以通过使用数据库的原子性特性或通过编程语言提供的原子操作实现。

#### 2. 分布式锁

在分布式系统中，可以使用分布式锁来确保在同一时间只有一个请求能够执行特定的操作。例如，使用Redis的SETNX命令或ZooKeeper的锁机制。当一个用户尝试创建订单时，系统先尝试获得锁，只有获得锁的请求可以继续执行，其他的请求将被阻塞或拒绝。

```java
import redis.clients.jedis.Jedis;

public class OrderProcessor {
    private static final String REDIS_HOST = "localhost";
    private static final int REDIS_PORT = 6379;
    private static final String LOCK_KEY = "product_id_123_lock";
    private static final int LOCK_EXPIRE_TIME = 10; // 锁的超时时间，单位为秒

    public static void main(String[] args) {
        Jedis jedis = new Jedis(REDIS_HOST, REDIS_PORT);

        // 生成一个唯一的锁值
        String lockValue = java.util.UUID.randomUUID().toString();

        // 尝试获取锁
        String result = jedis.set(LOCK_KEY, lockValue, "NX", "EX", LOCK_EXPIRE_TIME);

        if ("OK".equals(result)) {
            try {
                // 模拟订单处理逻辑
                processOrder();
            } finally {
                // 释放锁
                // 确保只有加锁者才能释放锁
                if (lockValue.equals(jedis.get(LOCK_KEY))) {
                    jedis.del(LOCK_KEY);
                }
            }
        } else {
            System.out.println("订单已在处理中");
        }

        // 关闭Jedis连接
        jedis.close();
    }

    private static void processOrder() {
        // 实现订单处理逻辑
        System.out.println("处理订单");
        // 假设这里将订单数据发送到订单子系统
    }
}

```

#### 3. 令牌桶或漏斗算法

这些算法通常用来控制流量，但也可以用来确保在特定时间内只处理一个请求。通过限制桶中的令牌数量（例如，设置为1），可以确保每次只有一个请求能够通过。

#### 4. 唯一标识符

在用户提交订单时，为每个请求分配一个唯一标识符，并且在后端系统中检查这个标识符是否已经存在或已被处理。只有第一个到达的具有唯一标识符的请求会被接受和处理。

#### 5. 消息队列

使用消息队列管理订单请求。每个请求被封装成一个消息，发送到队列中。队列处理消息的方式保证了消息的顺序处理。可以在消息处理逻辑中添加检查，确保只处理第一个有效的订单请求，后续的重复请求可以被忽略或拒绝。

#### 6. 数据库乐观锁

使用乐观锁机制，每次操作时检查某个版本号或时间戳。如果请求的版本号与数据库中的版本号匹配，则处理请求并更新版本号。如果不匹配，意味着有其他请求已经修改了数据，当前请求则会被拒绝。

### 如何防御机械人和自动脚本？

网关（zuul，nginx）层，为了避免前端恶意请求，比如一些攻击脚本，在网关层要对下单等接口按userID限流，几秒钟只能访问一次。考虑到秒杀场景参与人多，秒杀成功的人极少，我们可以把绝大部分抢购下单请求在网关层直接拒掉，按秒杀失败处理。这样就极大减少了后端服务的压力。

假设秒杀库存是200个，我们可以只放行200个请求到后端服务。要注意，为了尽量避免库存被机器人和自动脚本抢走，200个请求不能在秒杀开始瞬间同时放行，可以分段放行，比如秒杀开始后随机选取100ms内的5个请求放行（这100ms内的其他请求直接拒掉，按秒杀失败处理），之后每隔100ms放行5个请求，4秒钟可以放行完200个请求。分段放行，除了限制了机器人和自动脚本，把请求分散在各个时间段，还进一步缓解了后端服务的压力。

分段放行总时间不能太长，假如每100ms放行1个请求，放行完所有200个请求需要20秒时间，这样用户就会明显感知到下单早的人没秒杀成功，下单晚的人反而秒杀成功了，用户体验会变差。

### 使用Redis集群出现同步问题？导致超卖问题

顾名思义：“超卖”就是说卖出的商品数量比商品的库存数量多，这在电商领域是一个非常严重的问题。

Lua脚本完美解决超卖问题。我们可以**使用Lua脚本将Redis中扣减库存的操作封装成一个原子操作**，这样就能够保证操作的原子性，从而解决高并发环境下的同步问题。

> 当在Redis中运行Lua脚本时，整个脚本作为一个单独的事务执行。这意味着脚本中的所有命令在执行期间不会被其他Redis命令中断。这种原子性非常重要，因为它确保了数据的一致性和完整性。

例如，我们可以编写如下的Lua脚本代码，来执行Redis中的库存扣减操作。

```lua
local resultFlag = "0" 
local n = tonumber(ARGV[1]) 
local key = KEYS[1] 
local goodsInfo = redis.call("HMGET",key,"totalCount","seckillCount") 
local total = tonumber(goodsInfo[1]) 
local alloc = tonumber(goodsInfo[2]) 
if not total then 
    return resultFlag 
end 
if total >= alloc + n  then 
    local ret = redis.call("HINCRBY",key,"seckillCount",n) 
    return tostring(ret) 
end 
return resultFlag
```

我们可以使用如下的Java代码来调用上述Lua脚本。

```java
public int secKill(String id, int number) { 
    String key = getCacheKey(id); 
    Object seckillCount =  redisTemplate.execute(script, Arrays.asList(key), String.valueOf(number)); 
    return Integer.valueOf(seckillCount.toString()); 
}
```

这样，我们在执行秒杀活动时，就能够保证操作的原子性，从而有效的避免数据的同步问题，进而有效的解决了“超卖”问题。

**为了应对秒杀系统高并发大流量的业务场景，除了秒杀系统本身的业务架构外，我们还要进一步优化服务器硬件的性能，接下来，我们就一起来看一下如何优化服务器的性能。**

## 参考链接

+ 如何设计电商行业亿级用户秒杀系统-阿里云开发者社区: https://developer.aliyun.com/article/764233
+ 电商秒杀系统架构分析与实战！ - 知乎: https://zhuanlan.zhihu.com/p/400069193
+ 实践出真知：全网最强秒杀系统架构解密，不是所有的秒杀都是秒杀！！-云社区-华为云: https://bbs.huaweicloud.com/blogs/300953