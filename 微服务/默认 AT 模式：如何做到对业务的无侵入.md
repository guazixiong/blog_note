# seata默认 AT 模式：如何做到对业务的无侵入

提供无侵入自动补偿的事务模式。

免费的是AT，收费的是阿里云GTS。

1.  AT模式如何做到对业务的无侵入。

    + 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
    
    + 二阶段：
      + 提交异步化，非常快速地完成。
      + 回滚通过一阶段的回滚日志进行反向补偿。(反向补偿：前面做了insert，后面回滚时做delete)

2.  几个表

    我们的每个数据库都有一个自身的数据表和一个事务的回滚表：`undo_log`
    
    seata库中有这几个表：
    
    + branch_table
    + global_table
    + lock_table

![img](%E9%BB%98%E8%AE%A4%20AT%20%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%97%A0%E4%BE%B5%E5%85%A5.assets/20210129225116.png)

## 一阶段，二阶段提交 / 二阶段回滚

我们解释一下一阶段，二阶段提交/二阶段回滚

### 一阶段加载

在一阶段,Seata会拦截“业务SQL”

1. 解析SQL语义,找到“业务SQL”,要更新的业务数据,在业务数据被更新前,将其保存为`before image`(保存原有数据,便于后续回滚)
2. 执行“业务SQL”更新业务数据,在业务数据更新之后,将其保存为`after image`(保存更新的数据),最后生成行锁.

以上操作都在一个数据库事务内完成,这样保证了这一阶段操作的原子性.

![image-20240423161330839](%E9%BB%98%E8%AE%A4%20AT%20%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%97%A0%E4%BE%B5%E5%85%A5.assets/image-20240423161330839.png)

### 二阶段提交

二阶段顺利提交的话,因为“业务SQL”在一阶段已经提交至数据库,所以Seata框架只需将**一阶段保存的快照数据和行锁删除,完成数据清理即可**

![image-20240423161953924](%E9%BB%98%E8%AE%A4%20AT%20%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%97%A0%E4%BE%B5%E5%85%A5.assets/image-20240423161953924.png)

### 二阶段回滚

二阶段如果是回滚的话,Seata就需要回滚一阶段已经执行的“业务SQL”,还原业务数据(反向补偿);

> 还原之前要检验一下`脏写`,因为高并发的情况下或者出现了异常,不排除被其他调用修改.

回滚方式便是用`before image` 还原业务数据; 但在还原前要校验脏写,对比“数据库当前业务数据”和“after image”,如果两份数据完全一致就说明没有脏写,可以还原业务数据,如果不一致就说明存在脏写,出现脏写就需要转人工处理.

![image-20240423162032890](%E9%BB%98%E8%AE%A4%20AT%20%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%97%A0%E4%BE%B5%E5%85%A5.assets/image-20240423162032890.png)

### 为什么Seata库中的几张表都没有数据呢?

全局事务提交会删除,回滚时也会删除.

### Seata执行流程图

![img](%E9%BB%98%E8%AE%A4%20AT%20%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%97%A0%E4%BE%B5%E5%85%A5.assets/20210129225201.png)